---
layout: post
title: "The X-bar Revolution: Why Binary Branching Matters"
date: 2025-11-16 16:00
categories: syntax
---

## Introduction

I've just finished Chapter 6 of Carnie (2021b). My initial take when I started this chapter was that X-bar was just a new formalism, compared to the trees I had drawn until now using the workbook companion Carnie (2021a).
Honestly I was wrong, X-bar theory is much more than a formalism to draw nice balanced syntax trees, it actually opens new doors by allowing us to represent more complex structures with more precision (for example accounting for more accurate constituency definitions). It also overcomes the limitations of the former way of drawing trees that Carnie used in the first one-third of the book and builds up on the structural analysis presented so far in the book.

In this post, I'll explore the specific problems X-bar theory solves and why its constraints give us more analytical power.

## The Problem with Phrase Structure Rules

At the end of Chapter 3, we had accumulated 9 PSRs (Phrase Structure Rules), a list that overloads our memory but more importantly limits systematic analysis:

- CP -> (C) TP
- TP -> {NP/CP} (T) VP
- VP -> (AdvP+) V (NP) ({NP/CP}) (AdvP+) (PP+) (AdvP+)
- NP -> (D) (AdjP+) N (PP+) (CP)
- PP -> P (NP)
- AdjP -> (AdvP) Adj
- AdvP -> (AdvP) Adv
- XP -> XP conj XP
- X -> X conj X

Looking at these rules, we can see parallels that are hidden by the separate formulations:

- AdjP and AdvP (similar but not symmetric with regards to AdvP)
- CP and PP (very similar in their structure)
- Conjunctions rules (identical if you substitute X for XP)

These rules, together with structural relations like c-command and binding gave us some very useful tools like constituency tests. They allow us to define anaphors. However, their flat structure becomes problematic for more complex sentences.

Let's look at an example: _the big car of my neighbour with the red stripes_

  <div style="text-align: center;">
    <img src="{{ site.baseurl }}/assets/images/the-big-car.png" alt="Syntax tree" width="500">
    <br><br><i>the big car of my neighbour with red stripes</i>
  </div>

  <div style="text-align: center;">
    <br><i>Images drawn by <a href="https://yohasebe.com/rsyntaxtree" target="_blank">Rsyntaxtree</a> by Yochiro Hasebe</i><br><br>
  </div>

If we apply the constituency test known as _one-replacement_ where we replace a possible constituent with _one_, we may end up with results unpredicted by the PSR and the tree we had so far:

- I saw the big _[car of my neighbour with the red stripes]_ not the small _[one]_.

This would predict that "car of my neighbour with the red stripes" should be a constituent. But in the flat structure generated by our PSR, there is no single node that exhaustively dominates this particular string, the NP dominates too much (includes "the big") and the N dominates too little.

As a reminder, this is the definition of constituency (Chapter 4): "a constituent is a set of terminal nodes exhaustively dominated by a particular node".

### What was missing?

The flat PSR approach faced two related problems. First, empirically it couldn't represent some intermediate levels of structure, so constituency tests like one-replacement revealed constituents that our tree didn't capture. Second, theoretically, the separate rules for each category obscured the generalization that all phrases share the same basic architecture: a head that combines with its complements and potentially with adjuncts.

Our rules are too specific in some ways (separate rules for each category), yet too permissive in others (allowing structures that are impossible). X-bar theory addresses both problems through a single elegant insight: all phrases, regardless of category, have the same hierarchical structure.

## Enter X-bar Theory: Uniform Phrase Structure

X-bar succeeds at rephrasing all rules, reducing their number and proposing a formalism that overcomes all limitations of the former flat structure.

Here are the new rules (3 core rules with their language-specific variants):

- Specifier rule: XP -> (YP) X' or XP -> X' (YP)
- Adjunct rule: X' -> X' (ZP) or X' -> (ZP) X'
- Complement rule: X' -> X (WP) or X' -> (WP) X

Note: in these rules the alternative formulations are mentioned to account for cross-linguistic features (like head-last languages like Japanese), only the first formulation is applicable to English.

Additional rules:

- CP -> (C) TP
- TP -> NP (T) VP (note that this rule is temporary as we're only at Chapter 6)
- XP -> XP conj XP
- X' -> X' conj X'
- X -> X conj X

When I encountered X-bar theory, my initial reaction was "of course", intuitively I knew something was wrong with the former version, too many repetitions and a severe lack of generalization.

### The X-bar Schema

The X-bar schema is a binary tree, the base schemas are:

- Head + Specifier

```text
     XP
   /   \
 Spec   X'
```

- Head + complement

```text
    X'
   /  \
  X    Complement

```

- Head + Complement + Adjunct

```text
     X'
    /  \
 Adj    X'
       /  \
      X   Comp
```

Let's also draw the X-bar tree from our example above:

  <div style="text-align: center;">
    <img src="{{ site.baseurl }}/assets/images/the-big-car-xbar.png" alt="Syntax tree" width="700">
    <br><br><i>the big car of my neighbour with red stripes</i>
  </div>

  <div style="text-align: center;">
    <br><i>Images drawn by <a href="https://yohasebe.com/rsyntaxtree" target="_blank">Rsyntaxtree</a> by Yochiro Hasebe</i><br><br>
  </div>

At first, the x-bar tree takes more space, this is because of the binary-branching requirement and this is also due to the strict application of the X-bar rules, where you sometimes see tree fragments similar to this one:

```text
   N'
  /  \
 X    N'
      |
      N
   stripes
```

Now we see why one-replacement works: [car of my neighbour with the red stripes] is a constituent, exhaustively dominated by a single N' node, making it a constituent that can be replaced by [one]. The intermediate N' level that X-bar theory gives us captures exactly the constituent that our flat PSR structure missed.

### Binary Branching: A Fundamental Constraint

As we just saw in the example above, binary branching forces us to be very explicit and very detailed at the cost of verbosity but X-bar trees must be rigorous and complete. It took me a lot of trials to be able to draw these trees (not always right at the first try by the way).

Carnie (2021a) is an absolutely essential resource if you want to be able to draw correct X-bar trees, it's full of examples with clear explanations of alternatives when there are any. That's something I learned: most of the time, there is no one single correct tree, several options are often available and acceptable.

The binary structure of these trees makes it easier to identify relations like c-command, in our example, we can see that [the] c-commands [car] for example.

## Conclusion

This post was dense (but less dense than the drawing tens of trees just to get used to it!). I had no idea what to expect from X-bar theory, I had just seen it mentioned on book covers or in paper titles. Flat trees and PSRs were already a discovery for me, but X-bar pushes further with a much more systematic approach. Now I feel like I'm starting to get a hold of it. I see how it structures a sentence in a systematic way (but I know the sentences I have seen so far are relatively simple).

As I've been working through exercises in English, I wonder how this would apply to other languages I know to some extent like French (head-initial like English) or Japanese (head-final)?

## References and Further Reading

Carnie, Andrew (2021a) _The Syntax Workbook A Companion to Carnie's Syntax_, second edition, Wiley-Blackwell  
Carnie, Andrew (2021b) _Syntax A Generative Introduction_, fourth edition. Wiley-Blackwell
